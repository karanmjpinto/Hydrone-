#Information about the track, processed from matlab
#Essentially a wrapper for what the datamanager already does
from math import pi, sqrt, cos, sin, radians
import numpy as np

class TrackData:
    def __init__(self, table):
        self.Z = table[:,3]
        self.Distance = table[:,6]
        self.d = table[:,7]
        self.TurnR = table[:,8]
        self.Grad = table[:,9]
        self.angle = table[:,10]
        
        self.dataLength = len(self.Distance)
        
        self.Z = np.concatenate((self.Z, self.Z, self.Z), axis=0)
        self.Distance = np.concatenate((self.Distance, self.Distance, self.Distance), axis=0)
        self.d = np.concatenate((self.d, self.d, self.d), axis=0)
        self.TurnR = np.concatenate((self.TurnR, self.TurnR, self.TurnR), axis=0)
        self.Grad = np.concatenate((self.Grad, self.Grad, self.Grad), axis=0)
        self.angle = np.concatenate((self.angle, self.angle, self.angle), axis=0)

#Information about car and the general enviroment
class CarData:
    def __init__(self):
        self.M = 50+50 #kg
        self.FrontA = 0.393 #m^2
        self.WheelDiam = 0.478 # m
        self.WheelRad = self.WheelDiam/2 # m
        self.WheelFrontM = 0.8226 # kg
        self.WheelBackM = 5.26662 # kg
        self.WheelCirc = pi*self.WheelDiam #m
        self.IWheelBack = 0.06403299  #kgm2
        self.IWheelFront = 0.039674395  #kgm2
        self.ElecEff1= 0.96 
        self.ElecEff2= 0.96 
        self.g = 9.81 # m/s^2
        self.rhoair = 1.23  # kg/m^3
        self.CR = 0.00162  #0.004 # Rolling Resistance Coeff.
        self.Cd = 0.08  # Drag Coefficient
        self.TMax = 37  #Nm max torque from motor 37.5 really but questionable
        self.MaxLatForce = 200  #N
        self.BrakeDecel = 3  #M/s^2 (magnitude, should be positive)

#Information about how we are going to run the race
class RaceData:
    def __init__(self):
        self.LookAheadDist = 300
        self.AcclSectLength = 15
        self.MinAccel = 0.2
        self.TargetSpeedIn= 4 #m/s
        self.TargetSpeedConst= 5.5 #m/s

#This stores the information generated by one race section
class RaceLoop:
    def __init__(self):
        self.i = None
        self.Position = None
        
        self.VSpeedIn = 4.9
        self.Grad = 0
        self.Dist = 0
        self.DistanceTotal = 0 #Starting at beginning
        self.Status = 'AccOn' #'AccOn' or 'Coast'
        self.AcclCount = 0
        self.TargetSpeed = 7.3
        self.AValAvail = 0
        

def Throttle(TrackData, RL, CD, RD):

    #Set TURN, which applied braking if going too quickly
    #https://en.wikipedia.org/wiki/Centripetal_force
    shouldBrake = False
    for i in range(RL.i, RL.i+100):
        RadLkAhd = TrackData.TurnR[i]

        if not np.isnan(RadLkAhd):
            MaxCornSpeed = sqrt((CD.MaxLatForce*RadLkAhd)/CD.M)
            DistToCorn = TrackData.Distance[i] - TrackData.Distance[RL.i]
            if ((RL.VSpeedIn - MaxCornSpeed)/CD.BrakeDecel) > (DistToCorn/RL.VSpeedIn):
                shouldBrake = True

            break

    if not np.isnan(TrackData.TurnR[RL.i]):
        LatForce = (CD.M * (RL.VSpeedIn**2))/TrackData.TurnR[RL.i]
        TURN = CD.MaxLatForce/LatForce
    else:
        TURN = 1

    if TURN >= 1:
        TURN = 1
        #RL.Notes=''
    #else:
        #RL.Notes=char(['Turning too fast, turn: ',num2str(TURN)])


    MinCornI = RD.LookAheadDist
    MinCorn = None
    for i in range(RL.i, RL.i+RD.LookAheadDist):
        if not np.isnan(TrackData.TurnR[i]):
            MinCorn = TrackData.TurnR[i]
            MinCornI = i
            break

    #Fails if indexes are equal, so handle explicitely        
    if RL.i == MinCornI:
        HeightDifZ = 0
    else:   
        HeightLkAhd = TrackData.Z[RL.i:MinCornI]
        MaxHeightI = np.argmax(HeightLkAhd)
        HeightDifZ = HeightLkAhd[MaxHeightI] - TrackData.Z[RL.i]
        
    HeightDifCorn = TrackData.Z[MinCornI] - TrackData.Z[RL.i]

    if (HeightDifCorn < 0) and (MinCornI < MaxHeightI): #Going downhill into a corner, before a hill
        MaxCornSpeed = sqrt((200*MinCorn)/CD.M)

        if (RL.TargetSpeed > MaxCornSpeed):
            RL.TargetSpeed = MaxCornSpeed
        else:
            RL.TargetSpeed = RD.TargetSpeedConst


    elif (HeightDifZ > 0): #No important corner, but hill needed to climb
        NeedSpeed = sqrt(CD.g * 2 * HeightDifZ)
        if (NeedSpeed > RD.TargetSpeedConst):
            RL.TargetSpeed = NeedSpeed
        else:
            RL.TargetSpeed = RD.TargetSpeedConst

    else: #Revert to normal
        RL.TargetSpeed = RD.TargetSpeedConst

    #Calculate correct action to take
    if shouldBrake:
        #RL.Notes = char([RL.Notes ' BRAKED - Look ahead'])
        
        #Explicit handling of negative values
        temp = RL.VSpeedIn**2 - (2*CD.BrakeDecel*TrackData.d[RL.i])
        if temp < 0:
            temp = 0
        RL.VSpeedIn = sqrt(temp)
        RL.AcclCount = 0

    elif TURN<1:
        #RL.Notes=char([RL.Notes ' BRAKED'])
        RL.VSpeedIn = TURN*RL.VSpeedIn
        RL.AcclCount = 0

    elif RL.AcclCount > 0: #Override overridden
        RL.PercentageRun = (RL.TargetSpeed-RL.VSpeedIn)/RL.TargetSpeed
        if RL.PercentageRun < RD.MinAccel:
            RL.PercentageRun = RD.MinAccel

        RL.AcclCount = RL.AcclCount - 1

    elif (RL.VSpeedIn < RL.TargetSpeed):

        RL.Status = 'AccOn'

        if (RL.AcclCount == 0):
            RL.AcclCount = RD.AcclSectLength

        RL.PercentageRun = (RL.TargetSpeed-RL.VSpeedIn)/RL.TargetSpeed
        if RL.PercentageRun<RD.MinAccel:
            RL.PercentageRun=RD.MinAccel

    elif RL.VSpeedIn >= RL.TargetSpeed:
        RL.PercentageRun = 0
        RL.Status = 'Coast'

    ## Torque Level
    if  RL.PercentageRun < 0:
        RL.PercentageRun = 0
        RL.Status = 'Coast'

    RL.OutputTorque = RL.PercentageRun*CD.TMax

    return RL

def VehicleResp(TrackData, RL, CD, RD):
    ## Vehicle Response
    # Vehicle response to torque levels

    ## Dynamic Updates
    # Position, Lap data and distance data
    RL.Position = TrackData.Distance[RL.i] #Position

    #RL.Notes = char(['Notes:' RL.PortionOfTrack ', ' RL.Notes])

    RL.Dist = TrackData.d[RL.i]
    RL.DistanceTotal = RL.DistanceTotal + RL.Dist

    # Input track data from array TrackData
    RL.Grad = TrackData.angle[RL.i]

    ## Resistances
    # Static Resistance
    RL.RollR = CD.M * CD.g * CD.CR * cos(radians(RL.Grad))#N # assuming the same rolling resistance for each wheel      (checked)
    RL.GradientR = CD.M * CD.g * sin(radians(RL.Grad))# N            (checked)
    RL.StaticR = RL.RollR + RL.GradientR

    ## Solving for available Torque and Acceleration
    if RL.Status == 'Coast':
        # torque version
        QA = (CD.M*CD.WheelRad+(CD.IWheelBack +(2*CD.IWheelFront))/CD.WheelRad+(RL.Dist*(0.25)*CD.rhoair*CD.WheelRad*CD.Cd*CD.FrontA))**2
        QB = (-2*(-RL.StaticR*CD.WheelRad-((0.25)*CD.rhoair*CD.WheelRad* CD.Cd* CD.FrontA*(RL.VSpeedIn**2)))*(CD.M*CD.WheelRad+(CD.IWheelBack +(2*CD.IWheelFront))/CD.WheelRad+(RL.Dist*(0.25)*CD.rhoair*CD.WheelRad* CD.Cd* CD.FrontA)))-((1/8)*RL.Dist*(CD.Cd*CD.rhoair*CD.WheelRad*CD.FrontA*RL.VSpeedIn)**2)
        QC = ((-RL.StaticR*CD.WheelRad-((0.25)*CD.rhoair*CD.WheelRad* CD.Cd* CD.FrontA*(RL.VSpeedIn**2)))**2)-((1/4)*CD.rhoair*CD.WheelRad* CD.Cd* CD.FrontA*(RL.VSpeedIn**2))**2

    else:
        # torque version
        QA = (CD.M*CD.WheelRad+(CD.IWheelBack +(2*CD.IWheelFront))/CD.WheelRad+(RL.Dist*(0.25)*CD.rhoair*CD.WheelRad*CD.Cd*CD.FrontA))**2
        QB = (-2*((RL.OutputTorque)-RL.StaticR*CD.WheelRad-((0.25)*CD.rhoair*CD.WheelRad* CD.Cd* CD.FrontA*(RL.VSpeedIn**2)))*(CD.M*CD.WheelRad+(CD.IWheelBack +(2*CD.IWheelFront))/CD.WheelRad+(RL.Dist*(0.25)*CD.rhoair*CD.WheelRad* CD.Cd* CD.FrontA)))-((1/8)*RL.Dist*(CD.Cd*CD.rhoair*CD.WheelRad*CD.FrontA*RL.VSpeedIn)**2)
        QC = (((RL.OutputTorque)-RL.StaticR*CD.WheelRad-((0.25)*CD.rhoair*CD.WheelRad* CD.Cd* CD.FrontA*(RL.VSpeedIn**2)))**2)-((1/4)*CD.rhoair*CD.WheelRad* CD.Cd* CD.FrontA*(RL.VSpeedIn**2))**2

    # Available Acceleration and average Speed updates
    temp = (QB**2)-(4*QA*QC)
    if temp < 0:
        temp = 0
        
    RL.AValAvail = (-QB-sqrt(temp))/(2*QA)
    RL.VSpeedEnd = sqrt((RL.VSpeedIn**2) + 2*RL.AValAvail*RL.Dist) #m/s
    RL.VSpeedAv = (RL.VSpeedEnd+RL.VSpeedIn)/2

    # Rotational speeds and accelerations
    RL.RaVal = RL.AValAvail/(CD.WheelRad)# rad/s**2
    RL.RSpeed = RL.VSpeedAv*60/(pi*CD.WheelDiam)#RPM
    RL.ASpeed = RL.RSpeed*2*pi/60 #Rad/s


    ## Resistances
    # Dynamic Resistances
    RL.AeroR = (0.5)*CD.rhoair* CD.Cd* CD.FrontA*(RL.VSpeedAv**2) # N        (checked)
    RL.DriveR = CD.M*RL.AValAvail# N              (checked)
    RL.InertRTorque = RL.RaVal*(CD.IWheelBack +(2*CD.IWheelFront))# Nm       (checked)
    RL.InertR = RL.InertRTorque* CD.WheelRad# N           (checked)

    # Total Resistance
    RL.RFTot = RL.StaticR + RL.AeroR + RL.DriveR + RL.InertR# N

    return RL
    
def PowerResp(RL, CD):
    ## Power Production
    # The power production side
    if RL.Status == 'Coast':
        #FuelUsedConstant
        RL.MotorState= 'Coast'
        RL.FCState = 'Off'
        RL.FuelEfficiencyLocal = 0
        RL.FuelEfficiencyLocalcalc = 0
        RL.MotorEff = 1#'N/A'
        RL.MotorPIn = 0
        RL.MotorPOut = 0
        RL.DriveP = 0#W
        RL.DriveT = 0#Nm
        RL.FCPIn = 0
        RL.ElecPIn =0
        RL.FCEff = 1#'N/A'
        RL.FuelConsump = 0
        RL.FuelConsumpcalc = 0
    else:

        RL.DriveP = RL.RFTot*RL.VSpeedAv#W
        RL.DriveT = RL.RFTot*CD.WheelRad#Nm
        RL.MotorPOut = RL.OutputTorque*RL.ASpeed#W
        OutputTorque = RL.OutputTorque

        #Calculate Motor efficiency
        if OutputTorque > 0 and OutputTorque <= 10:
            RL.MotorState = 'Running'
            RL.MotorEff = (-0.004420321*(OutputTorque**2)) +(0.106883204*OutputTorque) +	0.042251935
        elif OutputTorque > 10 and OutputTorque <= 30:
            RL.MotorState = 'Running'
            RL.MotorEff = (-0.000692995*(OutputTorque**2))+(0.03003544*OutputTorque)+0.456065934
        elif OutputTorque > 30 and OutputTorque<=37.5:
            RL.MotorState='Running'
            RL.MotorEff = (-0.000535714*(OutputTorque**2))+(0.019857143*OutputTorque)+0.618
        elif OutputTorque > 37.5 and OutputTorque <= 38:
            RL.MotorState='Running'
            RL.MotorEff = 0.35
        elif OutputTorque > 38:
            RL.MotorState='Running'
            RL.MotorEff = 0.25
        elif OutputTorque == 0: #Catching exceptions
            RL.MotorPIn = 0
            RL.MotorEff = 'N/A'
            RL.MotorState='PassedRules'
            #RL.Notes=char([RL.Notes 'No torque, motor should be off'])

        if RL.MotorState == 'Running':
            #Power required by motor for required Torque
            RL.MotorPIn = RL.MotorPOut/RL.MotorEff
            RL.ElecPIn = RL.MotorPIn/(CD.ElecEff1*CD.ElecEff2)

        else:
            RL.ElecPIn=0
            RL.MotorPIn=0
            RL.MotorEff = 1.5
            #RL.Notes=char([RL.Notes 'Motor Calc Problem'])

        ## Basic System

        if RL.ElecPIn>0 and RL.ElecPIn<=211.5:
            RL.FuelConsumpcalc = 0.016973995*(RL.ElecPIn)-2.22045E-16
            RL.FCState='Running'

        elif RL.ElecPIn> 211.5 and RL.ElecPIn<=408:
            RL.FuelConsumpcalc = 0.003053435*(RL.ElecPIn)+2.944198473
            RL.FCState='Running'

        elif RL.ElecPIn>408 and RL.ElecPIn<=1000:
            RL.FuelConsumpcalc = 0.012403748*(RL.ElecPIn)-1.139490754
            RL.FCState='Running'

        elif RL.ElecPIn<=0:
            RL.FCPIn = 0
            RL.FCEff = 1.5
            RL.FCState='PassedR'
            RL.FuelConsump = 0
            RL.FuelConsumpcalc = 0
            #RL.Notes=char([RL.Notes 'Electrical Power too low'])
        else:
            RL.FCEff = 1.5
            RL.FCState='OVRLDNA'
            #RL.Notes=char([RL.Notes 'Fuel Cell Power Too High'])

    ## Updating for next loop
    RL.VSpeedIn=RL.VSpeedEnd
    
    return RL
